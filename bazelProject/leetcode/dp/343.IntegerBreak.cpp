#include "343.IntegerBreak.h"
#include <vector>
#include <cmath>
using namespace std;

// https://lucifer.ren/blog/2020/05/16/343.integer-break/

// f(n) = max(1 * f(n-1), 1 * (n - 1), 2 * f(n-2), 2 * (n - 2), 3 * f(n-3), 3 * (n - 3), ..., (n-2) * f(2), (n - 2) * 3, (n-1) * f(1), (n - ) * 1);

int integerBreak(int n)
{   
    vector<int> dp(n + 1, 1);
    for(int i = 3; i <=n; ++i)
    {
        for(int j = 1; j < i; ++j) {
            dp[i] = max(max(dp[i], j * dp[i - j]), j * (i - j)); // 需要注意i * f(n - i) 并不一定最大值，还要考虑i * (i - j)
        }
    }

    return dp[n];
}

// 题目提示中让用 O(n) 的时间复杂度来解题，而且告诉我们找7到 10 之间的规律，那么我们一点一点的来分析：

// 正整数从1开始，但是1不能拆分成两个正整数之和，所以不能当输入。

// 那么2只能拆成 1+1，所以乘积也为1。

// 数字3可以拆分成 2+1 或 1+1+1，显然第一种拆分方法乘积大为2。

// 数字4拆成 2+2，乘积最大，为4。

// 数字5拆成 3+2，乘积最大，为6。

// 数字6拆成 3+3，乘积最大，为9。

// 数字7拆为 3+4，乘积最大，为 12。

// 数字8拆为 3+3+2，乘积最大，为 18。

// 数字9拆为 3+3+3，乘积最大，为 27。

// 数字10拆为 3+3+4，乘积最大，为 36。

// ....

// 那么通过观察上面的规律，我们可以看出从5开始，数字都需要先拆出所有的3，一直拆到剩下一个数为2或者4，因为剩4就不用再拆了，拆成两个2和不拆没有意义，而且4不能拆出一个3剩一个1，这样会比拆成 2+2 的乘积小。这样我们就可以写代码了，先预处理n为2和3的情况，然后先将结果 res 初始化为1，然后当n大于4开始循环，结果 res 自乘3，n自减3，根据之前的分析，当跳出循环时，n只能是2或者4，再乘以 res 返回即可：

int integerBreak1(int n)
{
    if(n <= 3) {
        return (n - 1);
    }

    int ans = 1;
    while(n > 4)
    {
        ans *= 3;
        n -= 3;
    }

    return ans * n;
}

// 我们再来观察上面列出的 10 之前数字的规律，我们还可以发现数字7拆分结果是数字4的三倍，而7比4正好大三，数字8拆分结果是数字5的三倍，而8比5大3，后面都是这样的规律，那么我们可以把数字6之前的拆分结果都列举出来，然后之后的数通过查表都能计算出来，参见代码如下；

int integerBreak2(int n)
{
    //                   0 2  3  4  5  6
    vector<int> dp = {0 ,1, 1, 2, 4, 6, 9};
    for(int i = 7; i <= n; ++i) {
        dp.push_back(dp[i - 3] * 3);
    }

    return dp[n];
}

// 下面这种解法是热心网友留言告诉博主的，感觉很叼，故而补充上来。是解法一的一种变形写法，不再使用 while 循环了，而是直接分别算出能拆出3的个数和最后剩下的余数2或者4，然后直接相乘得到结果，参见代码如下：
int integerBreak3(int n)
{
    if(n <= 3) return n - 1;
    if(n == 4) return n;
    n -= 5;
    return pow(3, (n / 3) + 1) * (n % 3 + 2);
}